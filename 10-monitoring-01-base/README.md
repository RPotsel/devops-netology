# 10.01. Зачем и что нужно мониторить

## Обязательные задания

1. Вас пригласили настроить мониторинг на проект. На онбординге вам рассказали, что проект представляет из себя 
платформу для вычислений с выдачей текстовых отчетов, которые сохраняются на диск. Взаимодействие с платформой 
осуществляется по протоколу http. Также вам отметили, что вычисления загружают ЦПУ. Какой минимальный набор метрик вы
выведите в мониторинг и почему?

__Ответ:__

Для первоначальной настройки системы мониторинга возьмем базовые метрики и в процессе эксплуатации платформы будем расширять базовый набор в сторону критичных сервисов. Это позволит нам сконцентрировать внимание на важных аспектах работы платформы, сэкономить ресурсы и быстро внедрить систему мониторинга. Для системных метрик мы можем сразу настроить систему автоматического оповещения при достижении пороговых значений (alerts). Предположим, что платформа размещена в облаке и мониторингом на уровне железа занимается провайдер.

### Мониторинг инфраструктуры (укажем пороговые значения):
- CPU: для мониторинга использования процессорного времени, будем фиксировать постоянно высокий уровень нагрузки в течение определенного времени
  - CPU idle < 10% в течение 10 минут;
  - CPU Load Average превышает количество доступных процессоров и не равно 0 в течение 5 минут.
- RAM: возьмем базовые параметры, позволяющие оценить высокую загруженность и начало процесса деградации
  - заполнение SWAP > 90% (актуально для версий ядра Linux младше третей);
  - активная запись в SWAP (swapin > 1 Мбайт/с) в течение 2-5 минут (актуально для новых версий ядра Linux);
  - используемая оперативная память > 85%.
- DISK: 
  - свободное место на диске (по каждому разделу) <10%;
  - нагрузка на диск (iostat) > 95% в течение 1 часа;
  - free inodes (по каждому разделу) <10%.  
NETWORK:
  - средняя входящая нагрузка >75%;
  - средняя исходящая нагрузка >75%.
NTP: синхронизация времени с эталонным
  - рассинхронизация времени на сервере с эталоном <> 0,5 сек в течение 5 мин.

### Мониторинг системного ПО
В зависимости от используемого в проекте программного обеспечения для организации работы сервисов, баз данных, web-серверов, application-серверов требуется настройка системы мониторинга для анализа ключевых показателей данных систем. Эля этого могут использоваться метрики предоставляемые самими системами или агентами систем мониторинга. Т.к. в нашей системе используется http протокол, определим базовый мониторинг внешнего состояния проекта:
  - HTTP CODE - http-код ответа отличается от «нормального» (2хх, 3хх) в течение 3 минут, показывает, что какая-либо страница недоступна для пользователей;
  - RESPONSE TIME - время ответа на запрос больше «нормального» в течение 3 минут, указывает на проблемы работы сервиса.

Чтобы понять как предоставляется наш продукт потребителям, может понадобится проверка доступности конкретных endpoint’ов сайта, проверка на наличие необходимого контента на определенной странице сайта, географически распределенный мониторинг доступности проекта из разных регионов и так далее.

### Мониторинг бизнес процессов
Чтобы правильно планировать бюджет на содержание цифровой инфрастуктуры, нужно знать характеристики нагрузки на инфраструктуру бизнес процессами, для нашего проекта можно определить следующие метрики:
- количество активных пользователей в системе;
- количество запросов на отчёты в течение 5 минут;
- количество выполненных отчётов в течение 5 минут;
- общее количество сохраненных отчётов;
- время выполнения запроса на прдоставление отчета в течение 5 минут;
- географический объём распределения сетевого трафика.

### Мониторинг безопасности
Базовый аудит для анализа процессов безопасности проекта, позволяет 
- Неудачные авторизации;
- Количество пользователей с привилегированными правами;
- Количество http-кодов ответа отличного от «нормального» (2хх, 3хх);
- Актуальность сертификатов.

2. Менеджер продукта посмотрев на ваши метрики сказал, что ему непонятно что такое RAM/inodes/CPUla. Также он сказал, 
что хочет понимать, насколько мы выполняем свои обязанности перед клиентами и какое качество обслуживания. Что вы 
можете ему предложить?

__Ответ:__

Можно предложить выделить ключевые метрики SLI и вывести на панель системы мониторинга значения соответствия метрик согласованным целям SLO. Так же можно показать среднюю длительность и количество не соответствия продукта SLO за временные периоды.

3. Вашей DevOps команде в этом году не выделили финансирование на построение системы сбора логов. Разработчики в свою 
очередь хотят видеть все ошибки, которые выдают их приложения. Какое решение вы можете предпринять в этой ситуации, 
чтобы разработчики получали ошибки приложения?

__Ответ:__

- можно написать скрипты для проверки логов на наличие ошибок и информировать разработчиков через группы рассылки.
- можно использовать бесплатную облачную версию Sentry, она должна покрыть потребности разработки.

4. Вы, как опытный SRE, сделали мониторинг, куда вывели отображения выполнения SLA=99% по http кодам ответов. 
Вычисляете этот параметр по следующей формуле: summ_2xx_requests/summ_all_requests. Данный параметр не поднимается выше 70%, но при этом в вашей системе нет кодов ответа 5xx и 4xx. Где у вас ошибка?

__Ответ:__

Возможно проблема в том, что не учитываются 1хх и 3хх коды. Правильная формула расчёта уровня предоставляемого обслуживания должна быть такой:

```
(summ_2xx_requests + summ_1xx_requests + summ_3xx_requests)/summ_all_requests
```

## Дополнительное задание (со звездочкой*) - необязательно к выполнению

Вы устроились на работу в стартап. На данный момент у вас нет возможности развернуть полноценную систему 
мониторинга, и вы решили самостоятельно написать простой python3-скрипт для сбора основных метрик сервера. Вы, как 
опытный системный-администратор, знаете, что системная информация сервера лежит в директории `/proc`. 
Также, вы знаете, что в системе Linux есть  планировщик задач cron, который может запускать задачи по расписанию.

Суммировав все, вы спроектировали приложение, которое:
- является python3 скриптом
- собирает метрики из папки `/proc`
- складывает метрики в файл 'YY-MM-DD-awesome-monitoring.log' в директорию /var/log 
(YY - год, MM - месяц, DD - день)
- каждый сбор метрик складывается в виде json-строки, в виде:
  + timestamp (временная метка, int, unixtimestamp)
  + metric_1 (метрика 1)
  + metric_2 (метрика 2)
  
     ...
     
  + metric_N (метрика N)
  
- сбор метрик происходит каждую 1 минуту по cron-расписанию

Для успешного выполнения задания нужно привести:

а) работающий код python3-скрипта,

б) конфигурацию cron-расписания,

в) пример верно сформированного 'YY-MM-DD-awesome-monitoring.log', имеющий не менее 5 записей,

P.S.: количество собираемых метрик должно быть не менее 4-х.
P.P.S.: по желанию можно себя не ограничивать только сбором метрик из `/proc`.

__Ответ:__

- [Скрипт](./src/awesome-monitoring.py)

```PYTHON
#!/usr/bin/env python3

import time as t
import datetime as dt
import json 

def get_cpu_data():
    '''
    return CPU information
    '''
    
    cpu_data = {
        "running_processes": 0,
        "total_processes": 0
    }

    with open('/proc/loadavg', 'r') as f:
        for string in f:
            la_1m, la_5m, la_15m, proc_info, newest_pid = string.split(' ')
            running_processes, total_processes = proc_info.split('/')

    cpu_data['running_processes'] = int(running_processes)
    cpu_data['total_processes'] = int(total_processes)
 
    return cpu_data


def get_mem_data():
    '''
    return memory information
    '''

    mem_data = {
        "mem_available": 0,
        "mem_active": 0,
        "swap_free": 0
    }

    with open('/proc/meminfo', 'r') as f:
        for string in f:
            if string.startswith("MemAvailable:"):
                mem_data['mem_available'] = string.split(':')[1].lstrip().split(' ')[0]
            elif string.startswith("Active:"):
                mem_data['mem_active'] = string.split(':')[1].lstrip().split(' ')[0]
            elif string.startswith("SwapFree:"):
                mem_data['swap_free'] = string.split(':')[1].lstrip().split(' ')[0]
    return mem_data


def get_uptime_data():
    '''
    return uptime hms format
    '''

    with open('/proc/uptime', 'r') as f:
        uptime_seconds = int(float(f.read().split(' ')[0].strip()))
    return str(uptime_seconds // 3600) + "h" \
        + str((uptime_seconds % 3600) // 60) + "m" \
        + str(uptime_seconds % 3600 % 60) + "s" 


def main():

    # Init log file location sting
    logs = f"/var/log/{dt.datetime.now().strftime('%Y-%m-%d')}-awesome-monitoring.log"

    # Gather data
    data_slice = {
        "timestamp": t.time_ns(),
        **get_cpu_data(),
        **get_mem_data(),
        "uptime": get_uptime_data()
    }

    # White log
    with open(logs, 'a') as f:
        f.write(json.dumps(data_slice) + '\n')

# Call a function from the main thread
if __name__ == "__main__":
    main()
```

- [Расписание cron](./src/cron-awesome-monitoring)

```BASH
# Place in /etc/cron.d/
SHELL=/bin/sh
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

* * * * * root python3 /opt/awesome-monitoring.py
```

- [Результат работы скрипта](./src/2022-07-05-awesome-monitoring.log.1)

```BASH
$ grep CRON /var/log/syslog
Jul  5 15:17:01 rp-srv-ntlg03 CRON[115976]: (root) CMD (   cd / && run-parts --report /etc/cron.hourly)
Jul  5 15:52:01 rp-srv-ntlg03 CRON[117552]: (root) CMD (python3 /opt/awesome-monitoring.py)
Jul  5 15:53:01 rp-srv-ntlg03 CRON[117622]: (root) CMD (python3 /opt/awesome-monitoring.py)
Jul  5 15:54:01 rp-srv-ntlg03 CRON[117637]: (root) CMD (python3 /opt/awesome-monitoring.py)
Jul  5 15:55:01 rp-srv-ntlg03 CRON[117720]: (root) CMD (python3 /opt/awesome-monitoring.py)
Jul  5 15:56:01 rp-srv-ntlg03 CRON[118615]: (root) CMD (python3 /opt/awesome-monitoring.py)
$ cat /var/log/2022-07-05-awesome-monitoring.log 
{"timestamp": 1657036321407239484, "running_processes": 1, "total_processes": 169, "mem_available": "1549404", "mem_active": "804572", "swap_free": "2060028", "uptime": "38h19m14s"}
{"timestamp": 1657036381477595061, "running_processes": 1, "total_processes": 170, "mem_available": "1549692", "mem_active": "804564", "swap_free": "2060028", "uptime": "38h20m14s"}
{"timestamp": 1657036441543534900, "running_processes": 1, "total_processes": 170, "mem_available": "1549344", "mem_active": "804736", "swap_free": "2060028", "uptime": "38h21m15s"}
{"timestamp": 1657036501785440840, "running_processes": 1, "total_processes": 170, "mem_available": "1549620", "mem_active": "804776", "swap_free": "2060028", "uptime": "38h22m15s"}
{"timestamp": 1657036561946313911, "running_processes": 3, "total_processes": 258, "mem_available": "961916", "mem_active": "1105996", "swap_free": "2058748", "uptime": "38h23m15s"}
{"timestamp": 1657036622158913906, "running_processes": 1, "total_processes": 255, "mem_available": "440472", "mem_active": "1167768", "swap_free": "2031356", "uptime": "38h24m15s"}
```